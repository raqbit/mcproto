package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

const (
	FuncMarshal   = "Write"
	FuncUnmarshal = "Read"
	WriterName    = "w"
	ReaderName    = "r"
	Directory     = "."
)

var (
	packetNames = flag.String("packet", "", "comma-separated list of packet names; must be set")
	output      = flag.String("output", "", "output file name; must be set")
)

func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of genpacket:\n")
	fmt.Fprintf(os.Stderr, "\tgenpacket -packet T\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("genpacket: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*packetNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	packets := strings.Split(*packetNames, ",")
	if len(*output) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	g := Generator{}

	g.parsePackage(Directory)

	g.file = jen.NewFile(g.pkg.name)

	g.file.HeaderComment(
		fmt.Sprintf("Code generated by \"genpacket %s\"; DO NOT EDIT.", strings.Join(os.Args[1:], " ")),
	)

	// Run generate for each packet.
	for _, packetName := range packets {
		if err := g.generate(packetName); err != nil {
			log.Fatal(err)
		}
	}

	// Save to file.
	outputName := *output
	err := g.file.Save(outputName)
	if err != nil {
		log.Fatalf("saving output: %s", err)
	}
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	file *jen.File // File to be generated
	pkg  *Package  // Package we are scanning.
}

type Package struct {
	name  string
	types *types.Package
	defs  map[*ast.Ident]types.Object
}

// parsePackage analyzes the single package constructed from the patterns and tags.
// parsePackage exits if there is an error.
func (g *Generator) parsePackage(dir string) {
	cfg := &packages.Config{
		Mode:  packages.NeedName | packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo,
		Tests: false,
	}
	pkgs, err := packages.Load(cfg, dir)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	g.addPackage(pkgs[0])
}

// addPackage adds a type checked Package and its syntax files to the generator.
func (g *Generator) addPackage(pkg *packages.Package) {
	g.pkg = &Package{
		name:  pkg.Name,
		types: pkg.Types,
		defs:  pkg.TypesInfo.Defs,
	}
}
func (g *Generator) generate(typeName string) error {
	obj := g.pkg.types.Scope().Lookup(typeName)

	if obj == nil {
		return errors.New("could not lookup type")
	}

	struc, ok := obj.Type().Underlying().(*types.Struct)

	if !ok {
		return fmt.Errorf("%s is not a struct type", typeName)
	}

	name := obj.Name()
	idName := strings.ToLower(name[:1])

	g.file.
		Func().
		Params(
			jen.Id(idName).
				Id("*" + obj.Name()),
		).
		Id(FuncMarshal).
		Params(jen.Id(WriterName).Qual("io", "Writer")).
		Error().
		BlockFunc(func(group *jen.Group) {
			if struc.NumFields() > 0 {
				group.Var().Err().Error()
			}

			for i := 0; i < struc.NumFields(); i++ {
				field := struc.Field(i)

				group.If(
					jen.Err().
						Op("=").
						Id(idName).
						Dot(field.Name()).
						Dot("Write").
						Call(
							jen.Id(WriterName),
						),
					jen.Err().Op("!=").Nil(),
				).Block(jen.Return().Err())
			}

			group.Return().Nil()
		})

	g.file.
		Func().
		Params(
			jen.Id(idName).
				Id("*" + obj.Name()),
		).
		Id(FuncUnmarshal).
		Params(jen.Id(ReaderName).Qual("io", "Reader")).
		Error().
		BlockFunc(func(group *jen.Group) {
			if struc.NumFields() > 0 {
				group.Var().Err().Error()
			}

			for i := 0; i < struc.NumFields(); i++ {
				field := struc.Field(i)

				group.If(
					jen.Err().
						Op("=").
						Id(idName).
						Dot(field.Name()).
						Dot("Read").
						Call(
							jen.Id(ReaderName),
						),
					jen.Err().Op("!=").Nil(),
				).Block(jen.Return().Err())
			}

			group.Return().Nil()
		})

	return nil
}
